---
title: "tidymodels"
author: "一把Fei刀"
date: 2024-2-5
date-modified: last-modified
number-sections: true
---

> 本篇是tidymodels包的学习笔记，主要参考文档是[Tidy Modeling with R](https://www.tmwr.org/)。

```{r}
#| label: setup
#| include: false
# tinytex::install_tinytex(bundle = 'TinyTeX-2', dir = "D:/TinyTex")
library(tinytex) # 用于转换pdf格式
# 其他包都用"install.packages()"安装
library(rticles) # 用于输出中文pdf
library(tidyverse) # 代码风格
library(knitr) # 用于输出
library(showtext) # 显示pdf中图片的字体
showtext_auto() # 自动显示图片中的文字
library(reticulate) # 调用python
library(gt) # 输出表格
library(gtExtras)
library(tidymodels)
```

## 建模基础

```{mermaid}
%%| echo: false
---
title: 建模的分类
---
flowchart LR
A[模型] --- B[描述性模型]
A --- C[推理模型]
A --- D[预测模型]
D --- E[无监督模型]
D --- F[监督模型]
E --- G["主成分分析(PCA)"]
E --- H[聚类]
E --- I[自动编码器]
F --- J[回归]
F --- K[神经网络]
```

```{mermaid}
%%| echo: false
---
title: 模型建模的一般步骤
---
flowchart LR
A[导入数据] --> B["清洗数据(tidy)"] ---> C["探索性数据分析(EDA)"] --> D[特征工程] --> E[建模与优化] --> F[评估] --> G[部署]
F -.-> C
```

## 练习数据和探索性数据分析

练习数据使用的是`modeldata`包中的`ames`数据集。数据集包括：

-   房屋特征house characteristics，如bedrooms, garage, fireplace, pool, porch等；
-   区位location；
-   地块信息lot information，如zoning, shape, size等；
-   条件和质量评级ratings of condition and quality；
-   成交价格sale price。

```{r}
#| label: data_import
data(ames)
dim(ames)
```

### 探索性数据分析-探索住宅特点

首先关注房屋的最终销售价格（美元）。使用直方图来查看销售价格的分布情况，如 @fig-0201 所示。

```{r}
#| label: sale_price
tidymodels_prefer() # 用于处理包之间的函数冲突，不会输出结果

ames |>
  ggplot(aes(x = Sale_Price)) +
  geom_histogram(bins = 50, col = "white") +
  theme_bw() -> fig_0201
```

```{r}
#| label: fig-0201
#| fig-cap: 销售价格（美元）

fig_0201
```

作图发现数据是偏态的，可以使用对数变换来处理。这种转换的优点是，不会预测出负销售价格的房屋，而且预测昂贵房屋的误差也不会对模型产生过大的影响。另外，对数变换还可以稳定方差，使得模型更容易拟合。结果如 @fig-0202 所示。

```{r}
#| label: log_sale_price

fig_0201 +
  scale_x_log10() -> fig_0202
```

```{r}
#| label: fig-0202
#| fig-cap: 对数变换后的销售价格（美元）

fig_0202
```

::: callout-caution
对数转换结果的主要缺点涉及到对**模型结果**的解释。在对数变换后，模型的系数不再是直接解释的，而是对数解释。这意味着，模型的系数是对数销售价格的变化，而不是销售价格的变化。这种情况下，需要小心解释模型的结果。
:::

对数转换的结果相对较好，因此可以使用对数转换后的销售价格作为目标变量。

```{r}
#| label: log_ames

ames |>
  mutate(Sale_Price = log10(Sale_Price)) -> ames
```

```{r}
#| label: save_tidymodels_0101
#| echo: false

save(ames, file = "../datas/tidymodels_0101.RData")
```

## 数据分割

```{r}
#| label: load_tidymodels_0101
#| echo: false

rm(list = ls())
load("../datas/tidymodels_0101.RData")
```

一般会将数据集分为训练集和测试集。训练集用于拟合模型，测试集用于评估模型的性能。

测试集只能使用一次，否则就会成为建模过程的一部分。这样会导致模型在测试集上的性能过于乐观，无法真实地评估模型的性能。

### 简单随机抽样

在`tidymodels`中，可以使用`initial_split()`函数来分割数据集。默认情况下，`initial_split()`函数会将数据集分为80%的训练集和20%的测试集。

```{r}
#| label: data_split_01

set.seed(123)

ames_split <- initial_split(ames, prop = 0.8)

ames_split
```

`ames_split`是一个`rsplit`对象，仅包含分区信息，可以使用`training()`和`testing()`函数来提取训练集和测试集。

```{r}
#| label: data_split_02

ames_train <- training(ames_split)
ames_test <- testing(ames_split)

dim(ames_train)
```

### 分层抽样

在某些情况下，需要使用分层抽样。例如，如果数据集中有一个重要的类别变量，那么就需要使用分层抽样来确保训练集和测试集中都包含这个类别变量的各个水平。

可以人为地将结果数据四等分，然后分别进行四次分层抽样，这样可以保持训练集和测试集的分布一致。

```{r}
#| label: fig-0203
#| fig-cap: 房屋销售价格分布(log)，虚线代表四分位数

ames |>
  pull(Sale_Price) |> # 提取销售价格
  density(n = 2^10) |> # 生成密度估计
  tidy() -> sale_dens # 将结果转换为数据框

tibble(prob = (1:3)/4, value = quantile(ames$Sale_Price, probs = prob)) |> # 计算四分位数
  mutate(y = approx(sale_dens$x, sale_dens$y, xout = value)$y) -> quartiles # 计算四分位数的密度值

ames |>
  ggplot(aes(x = Sale_Price)) +
  geom_line(stat = "density") +
  geom_segment(data = quartiles,
               aes(x = value, xend = value, y = 0, yend = y),
               lty = 2) +
  labs(x = "Sale Price (log-10 USD)", y = NULL) +
  theme_bw() -> fig_0203
fig_0203
```

销售价格的分布呈右偏态，廉价房屋的比例更大。因此，可以使用分层抽样来确保训练集和测试集中都包含廉价房屋。可以使用`strata`参数来指定分层变量。

```{r}
#| label: data_split_03

set.seed(123)
ames_split <- initial_split(ames, prop = 0.80, strata = Sale_Price)
ames_train <- training(ames_split)
ames_test  <-  testing(ames_split)

dim(ames_train)
```

::: callout-caution
只能使用单列作为分层变量，不能使用多列。
:::

### 交叉验证-验证集的分割

交叉验证通常用于解决模型过拟合的问题。为此，可以把数据集分为训练集、测试集和验证集，其中验证集用于调整模型的超参数。可以用`initial_vadilation_split()`函数来实现。

```{r}
#| label: data_split_04

set.seed(123)
ames_val_split <- initial_validation_split(ames, prop = c(0.6, 0.2))

ames_val_split

ames_val_train <- training(ames_val_split)
ames_val_test  <- testing(ames_val_split)
ames_val_val   <- validation(ames_val_split)
```

```{r}
#| label: save_tidymodels_0102
#| echo: false

save(ames, ames_split, ames_train, ames_test, file = "../datas/tidymodels_0102.RData")
```

## 模型拟合-以线性回归为例

```{r}
#| label: load_tidymodels_0102
#| echo: false

rm(list = ls())
load("../datas/tidymodels_0102.RData")
```

对于一些相对简单的模型，可以使用`parsnip`包中的`fit`和`predict`函数来拟合和预测。`parsnip`包提供了统一的接口，可以使用相同的函数来拟合不同的模型。

使用`parsnip`中的`linear_reg()`函数指定模型类型，`set_engine()`函数指定模型引擎，这里的引擎一般指的是具体建模使用的软件包名称。确定模型后，可以使用`fit()`函数或`fit_xy()`函数来拟合模型。以三种常用的线性回归模型为例。

```{r}
#| label: model_fit_translation

linear_reg() |>
  set_engine("lm") |>
  translate()

linear_reg(penalty = 1) |> # panalty是glmnet的特有参数
  set_engine("glmnet") |>
  translate()

linear_reg() |>
  set_engine("stan") |>
  translate()
```

> `translate()`函数可以提供模型转换的详细参数信息。\
> `missing_arg()`是占位符，表示数据未提供。

以经度和纬度为自变量，销售价格为因变量，拟合线性回归模型。

```{r}
#| label: model_fit_01

linear_reg() |>
  set_engine("lm") -> lm_model

lm_model |>
  fit(Sale_Price ~ Longitude + Latitude, data = ames_train) -> lm_form_fit

lm_model |>
  fit_xy(x = ames_train |>
           select(Longitude, Latitude),
         y = ames_train |>
           pull(Sale_Price)
  ) -> lm_xy_fit

lm_form_fit
lm_xy_fit
```

## 提取模型结果

`lm_form_fit`和`lm_xy_fit`是`parsnip`模型对象，拟合模型储存在`fit`属性中。可以使用`extract_fit_engine()`函数提取拟合模型。

```{r}
#| label: model_fit_get

lm_form_fit |>
  tidy() # 最简单的提取模型系数的方法（提取为tibble）

lm_form_fit |>
  extract_fit_engine() |> # 提取模型
  vcov() # 提取模型的协方差矩阵

lm_form_fit |>
  extract_fit_engine() |>
  summary() |> # 提取模型的摘要信息
  coef() # 提取模型的系数

lm_form_fit |>
  extract_fit_engine() |>
  gtsummary::tbl_regression() # 生成模型摘要信息
```

## 模型预测

使用`predict()`函数进行预测。

```{r}
#| label: model_predict

ames_test |>
  slice(1:5) -> ames_test_small # 选择前五行数据

predict(lm_form_fit, new_data = ames_test_small) # 预测结果

ames_test_small |>
  select(Sale_Price) |> # 真实值
  bind_cols(predict(lm_form_fit, ames_test_small)) |> # 预测值
  bind_cols(predict(lm_form_fit, ames_test_small, type = "pred_int")) # 预测区间
```

以决策树为例，对数据进行建模

```{r}
#| label: model_fit_02

decision_tree(min_n = 2) |>
  set_engine("rpart") |>
  set_mode("regression") -> tree_model

tree_model |>
  fit(Sale_Price ~ Longitude + Latitude, data = ames_train) -> tree_fit

ames_test_small |>
  select(Sale_Price) |> # 真实值
  bind_cols(predict(tree_fit, ames_test_small)) # 预测值
```

::: callout-important
可以在<https://www.tidymodels.org/find/>找所有可用的模型。

`parsnip_addin()`函数可以在RStudio中搜索模型。
:::

```{r}
#| label: save_tidymodels_0103
#| echo: false

save(ames, ames_split, ames_train, ames_test, lm_model, file = "../datas/tidymodels_0103.RData")
```

## workflow

### 创建workflow对象

使用`lm_model`来创建`workflow`对象，`workflow`对象可以将数据预处理和模型拟合整合在一起。

```{r}
#| label: load_tidymodels_0103
#| echo: false

rm(list = ls())
load("../datas/tidymodels_0103.RData")
```

```{r}
#| label: lm_model
#| eval: false

linear_reg() |>
  set_engine("lm") -> lm_workflow
```

```{r}
#| label: workflow_01

workflow() |>
  add_model(lm_model) -> lm_workflow

lm_workflow
```

::: callout-note
`lm_workflow`中，`Preprocessor`为空，代表没有数据预处理。
:::

### 添加预处理器

使用`add_formula`函数输入标准公式作为预处理器：

```{r}
#| label: workflow_02

lm_workflow |>
  add_formula(Sale_Price ~ Longitude + Latitude) -> lm_workflow

lm_workflow
```

`workflow`对象可以使用`fit()`函数拟合模型，使用`predict()`函数进行预测。

```{r}
#| label: workflow_03

lm_workflow |>
  fit(data = ames_train) -> lm_fit

lm_fit

lm_fit |>
  predict(new_data = ames_test |>
            slice(1:3)) # 预测

```

可以使用`update_formula`函数更新预处理器：

```{r}
#| label: workflow_04

lm_fit |>
  update_formula(Sale_Price ~ Longitude)
```

### 添加变量

使用`add_variables`函数添加变量。函数有两个参数：`outcomes`和`predictors`。支持使用`c()`函数添加多个变量。

```{r}
#| label: workflow_05

lm_workflow |>
  remove_formula() |>
  add_variables(outcome = Sale_Price, predictors = c(Longitude, Latitude)) -> lm_workflow # 和上面的add_formula等价

lm_workflow
```

拟合模型：

```{r}
#| label: workflow_06

fit(lm_workflow, data = ames_train) # 拟合模型
```

### 为`workflow`使用公式

#### 基于树的模型

使用`Orthodont`数据集，拟合一个受试者具有随机效应的回归模型。

在`workflow`中，使用`add_variables()`函数添加变量，使用`add_model()`函数添加模型。

```{r}
#| label: workflow_07

library(multilevelmod) # parsnip扩展包，主要用于多层次模型（混合效应模型、贝叶斯层次模型等）

data(Orthodont, package = "nlme")

linear_reg() |>
  set_engine("lmer") -> multilevel_spec # lmer是lme4包中的函数，用于拟合线性混合效应模型
  
workflow() |>
  add_variables(outcome = distance, predictors = c(Sex, age, Subject)) |> 
  add_model(multilevel_spec, 
            formula = distance ~ Sex + (age | Subject)) -> multilevel_workflow # age | Subject表示age是Subject的随机效应

multilevel_workflow |>
  fit(data = Orthodont) -> multilevel_fit

multilevel_fit
```

可以进一步使用`survival`包中的`strata`函数进行生存分析.

```{r}
#| label: workflow_08

library(censored) # parsnip扩展包，主要用于删减回归和生存分析模型

survival_reg() -> parametric_spec

data(cancer, package = "survival")

workflow() |>
  add_variables(outcome = c(fustat, futime), predictors = c(age, rx)) |>
  add_model(parametric_spec, 
            formula = Surv(futime, fustat) ~ age + strata(rx)) -> parametric_workflow

parametric_workflow |>
  fit(data = ovarian) -> parametric_fit

parametric_fit
```

### 同时创建多个workflow

做预测模型时，一般需要评估多个不同的模型。例如**筛选预测因子**。可以创建一组`formula`来罗列不同的预测因子组合。

```{r}
#| label: workflow_09

list(
  longitude = Sale_Price ~ Longitude,
  latitude = Sale_Price ~ Latitude,
  coords = Sale_Price ~ Longitude + Latitude,
  neighborhood = Sale_Price ~ Neighborhood) -> location

```

使用`workflow_set()`函数创建一个`workflow`集合。

```{r}
#| label: workflow_10

workflow_set(preproc = location, models = list(lm = lm_model)) -> location_models

location_models

location_models$info[[1]] # 查看第一个workflow的信息

extract_workflow(location_models, id = "coords_lm") # 提取一个workflow
```

为每个`formula`创建`fit`对象：

```{r}
#| label: workflow_11

location_models |>
  mutate(fit = map(info, ~ fit(.x$workflow[[1]], ames_train))) -> location_models # 使用map函数对每个workflow进行拟合

location_models

location_models$fit[[1]] # 查看第一个workflow的拟合结果
```

### 评估测试集

使用`last_fit`函数，可以把模型拟合到整个训练集，然后评估测试集。

```{r}
#| label: workflow_12

last_fit(lm_workflow, ames_split) -> final_lm_res # 用法：last_fit(模型, 数据分割)

final_lm_res

final_lm_res |>
  extract_workflow() # 提取workflow

final_lm_res |>
  collect_metrics() # 收集模型评估指标

final_lm_res |>
  collect_predictions() |> # 收集预测结果
  head()
```

```{r}
#| label: save_tidymodels_0104
#| echo: false

save(ames, ames_split, ames_train, ames_test, lm_model, lm_workflow, lm_fit, file = "../datas/tidymodels_0104.RData")
```
