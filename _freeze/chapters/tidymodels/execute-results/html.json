{
  "hash": "c3dca114d50f2f6de5fe855d026526a5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"tidymodels\"\nauthor: \"一把Fei刀\"\ndate: 2024-2-5\ndate-modified: last-modified\nnumber-sections: true\n---\n\n\n> 本篇是tidymodels包的学习笔记，主要参考文档是[Tidy Modeling with R](https://www.tmwr.org/)。\n\n\n\n\n\n## 建模基础\n\n\n```{mermaid}\n%%| echo: false\n---\ntitle: 建模的分类\n---\nflowchart LR\nA[模型] --- B[描述性模型]\nA --- C[推理模型]\nA --- D[预测模型]\nD --- E[无监督模型]\nD --- F[监督模型]\nE --- G[\"主成分分析(PCA)\"]\nE --- H[聚类]\nE --- I[自动编码器]\nF --- J[回归]\nF --- K[神经网络]\n```\n\n```{mermaid}\n%%| echo: false\n---\ntitle: 模型建模的一般步骤\n---\nflowchart LR\nA[导入数据] --> B[\"清洗数据(tidy)\"] ---> C[\"探索性数据分析(EDA)\"] --> D[特征工程] --> E[建模与优化] --> F[评估] --> G[部署]\nF -.-> C\n```\n\n\n## 练习数据和探索性数据分析\n\n练习数据使用的是`modeldata`包中的`ames`数据集。数据集包括：\n\n-   房屋特征house characteristics，如bedrooms, garage, fireplace, pool, porch等；\n-   区位location；\n-   地块信息lot information，如zoning, shape, size等；\n-   条件和质量评级ratings of condition and quality；\n-   成交价格sale price。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(ames)\ndim(ames)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2930   74\n```\n\n\n:::\n:::\n\n\n### 探索性数据分析-探索住宅特点\n\n首先关注房屋的最终销售价格（美元）。使用直方图来查看销售价格的分布情况，如 @fig-0201 所示。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidymodels_prefer() # 用于处理包之间的函数冲突，不会输出结果\n\names |>\n  ggplot(aes(x = Sale_Price)) +\n  geom_histogram(bins = 50, col = \"white\") +\n  theme_bw() -> fig_0201\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfig_0201\n```\n\n::: {.cell-output-display}\n![销售价格（美元）](tidymodels_files/figure-html/fig-0201-1.png){#fig-0201 width=672}\n:::\n:::\n\n\n作图发现数据是偏态的，可以使用对数变换来处理。这种转换的优点是，不会预测出负销售价格的房屋，而且预测昂贵房屋的误差也不会对模型产生过大的影响。另外，对数变换还可以稳定方差，使得模型更容易拟合。结果如 @fig-0202 所示。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfig_0201 +\n  scale_x_log10() -> fig_0202\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfig_0202\n```\n\n::: {.cell-output-display}\n![对数变换后的销售价格（美元）](tidymodels_files/figure-html/fig-0202-1.png){#fig-0202 width=672}\n:::\n:::\n\n\n::: callout-caution\n对数转换结果的主要缺点涉及到对**模型结果**的解释。在对数变换后，模型的系数不再是直接解释的，而是对数解释。这意味着，模型的系数是对数销售价格的变化，而不是销售价格的变化。这种情况下，需要小心解释模型的结果。\n:::\n\n对数转换的结果相对较好，因此可以使用对数转换后的销售价格作为目标变量。\n\n\n::: {.cell}\n\n```{.r .cell-code}\names |>\n  mutate(Sale_Price = log10(Sale_Price)) -> ames\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n## 数据分割\n\n\n::: {.cell}\n\n:::\n\n\n一般会将数据集分为训练集和测试集。训练集用于拟合模型，测试集用于评估模型的性能。\n\n测试集只能使用一次，否则就会成为建模过程的一部分。这样会导致模型在测试集上的性能过于乐观，无法真实地评估模型的性能。\n\n### 简单随机抽样\n\n在`tidymodels`中，可以使用`initial_split()`函数来分割数据集。默认情况下，`initial_split()`函数会将数据集分为80%的训练集和20%的测试集。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\names_split <- initial_split(ames, prop = 0.8)\n\names_split\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<Training/Testing/Total>\n<2344/586/2930>\n```\n\n\n:::\n:::\n\n\n`ames_split`是一个`rsplit`对象，仅包含分区信息，可以使用`training()`和`testing()`函数来提取训练集和测试集。\n\n\n::: {.cell}\n\n```{.r .cell-code}\names_train <- training(ames_split)\names_test <- testing(ames_split)\n\ndim(ames_train)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2344   74\n```\n\n\n:::\n:::\n\n\n### 分层抽样\n\n在某些情况下，需要使用分层抽样。例如，如果数据集中有一个重要的类别变量，那么就需要使用分层抽样来确保训练集和测试集中都包含这个类别变量的各个水平。\n\n可以人为地将结果数据四等分，然后分别进行四次分层抽样，这样可以保持训练集和测试集的分布一致。\n\n\n::: {.cell}\n\n```{.r .cell-code}\names |>\n  pull(Sale_Price) |> # 提取销售价格\n  density(n = 2^10) |> # 生成密度估计\n  tidy() -> sale_dens # 将结果转换为数据框\n\ntibble(prob = (1:3)/4, value = quantile(ames$Sale_Price, probs = prob)) |> # 计算四分位数\n  mutate(y = approx(sale_dens$x, sale_dens$y, xout = value)$y) -> quartiles # 计算四分位数的密度值\n\names |>\n  ggplot(aes(x = Sale_Price)) +\n  geom_line(stat = \"density\") +\n  geom_segment(data = quartiles,\n               aes(x = value, xend = value, y = 0, yend = y),\n               lty = 2) +\n  labs(x = \"Sale Price (log-10 USD)\", y = NULL) +\n  theme_bw() -> fig_0203\nfig_0203\n```\n\n::: {.cell-output-display}\n![房屋销售价格分布(log)，虚线代表四分位数](tidymodels_files/figure-html/fig-0203-1.png){#fig-0203 width=672}\n:::\n:::\n\n\n销售价格的分布呈右偏态，廉价房屋的比例更大。因此，可以使用分层抽样来确保训练集和测试集中都包含廉价房屋。可以使用`strata`参数来指定分层变量。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\names_split <- initial_split(ames, prop = 0.80, strata = Sale_Price)\names_train <- training(ames_split)\names_test  <-  testing(ames_split)\n\ndim(ames_train)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2342   74\n```\n\n\n:::\n:::\n\n\n::: callout-caution\n只能使用单列作为分层变量，不能使用多列。\n:::\n\n### 交叉验证-验证集的分割\n\n交叉验证通常用于解决模型过拟合的问题。为此，可以把数据集分为训练集、测试集和验证集，其中验证集用于调整模型的超参数。可以用`initial_vadilation_split()`函数来实现。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\names_val_split <- initial_validation_split(ames, prop = c(0.6, 0.2))\n\names_val_split\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<Training/Validation/Testing/Total>\n<1758/586/586/2930>\n```\n\n\n:::\n\n```{.r .cell-code}\names_val_train <- training(ames_val_split)\names_val_test  <- testing(ames_val_split)\names_val_val   <- validation(ames_val_split)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n## 模型拟合-以线性回归为例\n\n\n::: {.cell}\n\n:::\n\n\n对于一些相对简单的模型，可以使用`parsnip`包中的`fit`和`predict`函数来拟合和预测。`parsnip`包提供了统一的接口，可以使用相同的函数来拟合不同的模型。\n\n使用`parsnip`中的`linear_reg()`函数指定模型类型，`set_engine()`函数指定模型引擎，这里的引擎一般指的是具体建模使用的软件包名称。确定模型后，可以使用`fit()`函数或`fit_xy()`函数来拟合模型。以三种常用的线性回归模型为例。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlinear_reg() |>\n  set_engine(\"lm\") |>\n  translate()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n\nModel fit template:\nstats::lm(formula = missing_arg(), data = missing_arg(), weights = missing_arg())\n```\n\n\n:::\n\n```{.r .cell-code}\nlinear_reg(penalty = 1) |> # panalty是glmnet的特有参数\n  set_engine(\"glmnet\") |>\n  translate()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear Regression Model Specification (regression)\n\nMain Arguments:\n  penalty = 1\n\nComputational engine: glmnet \n\nModel fit template:\nglmnet::glmnet(x = missing_arg(), y = missing_arg(), weights = missing_arg(), \n    family = \"gaussian\")\n```\n\n\n:::\n\n```{.r .cell-code}\nlinear_reg() |>\n  set_engine(\"stan\") |>\n  translate()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear Regression Model Specification (regression)\n\nComputational engine: stan \n\nModel fit template:\nrstanarm::stan_glm(formula = missing_arg(), data = missing_arg(), \n    weights = missing_arg(), family = stats::gaussian, refresh = 0)\n```\n\n\n:::\n:::\n\n\n> `translate()`函数可以提供模型转换的详细参数信息。\\\n> `missing_arg()`是占位符，表示数据未提供。\n\n以经度和纬度为自变量，销售价格为因变量，拟合线性回归模型。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlinear_reg() |>\n  set_engine(\"lm\") -> lm_model\n\nlm_model |>\n  fit(Sale_Price ~ Longitude + Latitude, data = ames_train) -> lm_form_fit\n\nlm_model |>\n  fit_xy(x = ames_train |>\n           select(Longitude, Latitude),\n         y = ames_train |>\n           pull(Sale_Price)\n  ) -> lm_xy_fit\n\nlm_form_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nparsnip model object\n\n\nCall:\nstats::lm(formula = Sale_Price ~ Longitude + Latitude, data = data)\n\nCoefficients:\n(Intercept)    Longitude     Latitude  \n   -300.251       -2.013        2.782  \n```\n\n\n:::\n\n```{.r .cell-code}\nlm_xy_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nparsnip model object\n\n\nCall:\nstats::lm(formula = ..y ~ ., data = data)\n\nCoefficients:\n(Intercept)    Longitude     Latitude  \n   -300.251       -2.013        2.782  \n```\n\n\n:::\n:::\n\n\n## 提取模型结果\n\n`lm_form_fit`和`lm_xy_fit`是`parsnip`模型对象，拟合模型储存在`fit`属性中。可以使用`extract_fit_engine()`函数提取拟合模型。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_form_fit |>\n  tidy() # 最简单的提取模型系数的方法（提取为tibble）\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n  term        estimate std.error statistic  p.value\n  <chr>          <dbl>     <dbl>     <dbl>    <dbl>\n1 (Intercept)  -300.      14.6       -20.6 1.02e-86\n2 Longitude      -2.01     0.130     -15.5 8.13e-52\n3 Latitude        2.78     0.182      15.3 1.64e-50\n```\n\n\n:::\n\n```{.r .cell-code}\nlm_form_fit |>\n  extract_fit_engine() |> # 提取模型\n  vcov() # 提取模型的协方差矩阵\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            (Intercept)     Longitude      Latitude\n(Intercept)  212.620590  1.6113032179 -1.4686377363\nLongitude      1.611303  0.0168165968 -0.0008694728\nLatitude      -1.468638 -0.0008694728  0.0330018995\n```\n\n\n:::\n\n```{.r .cell-code}\nlm_form_fit |>\n  extract_fit_engine() |>\n  summary() |> # 提取模型的摘要信息\n  coef() # 提取模型的系数\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               Estimate Std. Error   t value     Pr(>|t|)\n(Intercept) -300.250929 14.5815154 -20.59120 1.022609e-86\nLongitude     -2.013413  0.1296788 -15.52615 8.126177e-52\nLatitude       2.781713  0.1816642  15.31239 1.639312e-50\n```\n\n\n:::\n\n```{.r .cell-code}\nlm_form_fit |>\n  extract_fit_engine() |>\n  gtsummary::tbl_regression() # 生成模型摘要信息\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"nhnzqqzgeq\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>#nhnzqqzgeq table {\n  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n#nhnzqqzgeq thead, #nhnzqqzgeq tbody, #nhnzqqzgeq tfoot, #nhnzqqzgeq tr, #nhnzqqzgeq td, #nhnzqqzgeq th {\n  border-style: none;\n}\n\n#nhnzqqzgeq p {\n  margin: 0;\n  padding: 0;\n}\n\n#nhnzqqzgeq .gt_table {\n  display: table;\n  border-collapse: collapse;\n  line-height: normal;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_caption {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n#nhnzqqzgeq .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#nhnzqqzgeq .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 3px;\n  padding-bottom: 5px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#nhnzqqzgeq .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#nhnzqqzgeq .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#nhnzqqzgeq .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#nhnzqqzgeq .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#nhnzqqzgeq .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#nhnzqqzgeq .gt_spanner_row {\n  border-bottom-style: hidden;\n}\n\n#nhnzqqzgeq .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  text-align: left;\n}\n\n#nhnzqqzgeq .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#nhnzqqzgeq .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#nhnzqqzgeq .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#nhnzqqzgeq .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#nhnzqqzgeq .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#nhnzqqzgeq .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#nhnzqqzgeq .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#nhnzqqzgeq .gt_row_group_first th {\n  border-top-width: 2px;\n}\n\n#nhnzqqzgeq .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#nhnzqqzgeq .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#nhnzqqzgeq .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#nhnzqqzgeq .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_last_grand_summary_row_top {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: double;\n  border-bottom-width: 6px;\n  border-bottom-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#nhnzqqzgeq .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#nhnzqqzgeq .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#nhnzqqzgeq .gt_left {\n  text-align: left;\n}\n\n#nhnzqqzgeq .gt_center {\n  text-align: center;\n}\n\n#nhnzqqzgeq .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#nhnzqqzgeq .gt_font_normal {\n  font-weight: normal;\n}\n\n#nhnzqqzgeq .gt_font_bold {\n  font-weight: bold;\n}\n\n#nhnzqqzgeq .gt_font_italic {\n  font-style: italic;\n}\n\n#nhnzqqzgeq .gt_super {\n  font-size: 65%;\n}\n\n#nhnzqqzgeq .gt_footnote_marks {\n  font-size: 75%;\n  vertical-align: 0.4em;\n  position: initial;\n}\n\n#nhnzqqzgeq .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#nhnzqqzgeq .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#nhnzqqzgeq .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#nhnzqqzgeq .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#nhnzqqzgeq .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#nhnzqqzgeq .gt_indent_5 {\n  text-indent: 25px;\n}\n</style>\n<table class=\"gt_table\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n  <thead>\n    \n    <tr class=\"gt_col_headings\">\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"&lt;strong&gt;Characteristic&lt;/strong&gt;\"><strong>Characteristic</strong></th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_center\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"&lt;strong&gt;Beta&lt;/strong&gt;\"><strong>Beta</strong></th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_center\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"&lt;strong&gt;95% CI&lt;/strong&gt;&lt;span class=&quot;gt_footnote_marks&quot; style=&quot;white-space:nowrap;font-style:italic;font-weight:normal;&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/span&gt;\"><strong>95% CI</strong><span class=\"gt_footnote_marks\" style=\"white-space:nowrap;font-style:italic;font-weight:normal;\"><sup>1</sup></span></th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_center\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"&lt;strong&gt;p-value&lt;/strong&gt;\"><strong>p-value</strong></th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td headers=\"label\" class=\"gt_row gt_left\">Longitude</td>\n<td headers=\"estimate\" class=\"gt_row gt_center\">-2.0</td>\n<td headers=\"ci\" class=\"gt_row gt_center\">-2.3, -1.8</td>\n<td headers=\"p.value\" class=\"gt_row gt_center\"><0.001</td></tr>\n    <tr><td headers=\"label\" class=\"gt_row gt_left\">Latitude</td>\n<td headers=\"estimate\" class=\"gt_row gt_center\">2.8</td>\n<td headers=\"ci\" class=\"gt_row gt_center\">2.4, 3.1</td>\n<td headers=\"p.value\" class=\"gt_row gt_center\"><0.001</td></tr>\n  </tbody>\n  \n  <tfoot class=\"gt_footnotes\">\n    <tr>\n      <td class=\"gt_footnote\" colspan=\"4\"><span class=\"gt_footnote_marks\" style=\"white-space:nowrap;font-style:italic;font-weight:normal;\"><sup>1</sup></span> CI = Confidence Interval</td>\n    </tr>\n  </tfoot>\n</table>\n</div>\n```\n\n:::\n:::\n\n\n## 模型预测\n\n使用`predict()`函数进行预测。\n\n\n::: {.cell}\n\n```{.r .cell-code}\names_test |>\n  slice(1:5) -> ames_test_small # 选择前五行数据\n\npredict(lm_form_fit, new_data = ames_test_small) # 预测结果\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 1\n  .pred\n  <dbl>\n1  5.22\n2  5.22\n3  5.28\n4  5.24\n5  5.31\n```\n\n\n:::\n\n```{.r .cell-code}\names_test_small |>\n  select(Sale_Price) |> # 真实值\n  bind_cols(predict(lm_form_fit, ames_test_small)) |> # 预测值\n  bind_cols(predict(lm_form_fit, ames_test_small, type = \"pred_int\")) # 预测区间\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n  Sale_Price .pred .pred_lower .pred_upper\n       <dbl> <dbl>       <dbl>       <dbl>\n1       5.02  5.22        4.91        5.54\n2       5.24  5.22        4.91        5.54\n3       5.28  5.28        4.97        5.60\n4       5.06  5.24        4.92        5.56\n5       5.60  5.31        5.00        5.63\n```\n\n\n:::\n:::\n\n\n以决策树为例，对数据进行建模\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndecision_tree(min_n = 2) |>\n  set_engine(\"rpart\") |>\n  set_mode(\"regression\") -> tree_model\n\ntree_model |>\n  fit(Sale_Price ~ Longitude + Latitude, data = ames_train) -> tree_fit\n\names_test_small |>\n  select(Sale_Price) |> # 真实值\n  bind_cols(predict(tree_fit, ames_test_small)) # 预测值\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  Sale_Price .pred\n       <dbl> <dbl>\n1       5.02  5.15\n2       5.24  5.15\n3       5.28  5.31\n4       5.06  5.15\n5       5.60  5.52\n```\n\n\n:::\n:::\n\n\n::: callout-important\n可以在<https://www.tidymodels.org/find/>找所有可用的模型。\n\n`parsnip_addin()`函数可以在RStudio中搜索模型。\n:::\n\n\n::: {.cell}\n\n:::\n\n\n## workflow\n\n### 创建workflow对象\n\n使用`lm_model`来创建`workflow`对象，`workflow`对象可以将数据预处理和模型拟合整合在一起。\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlinear_reg() |>\n  set_engine(\"lm\") -> lm_workflow\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nworkflow() |>\n  add_model(lm_model) -> lm_workflow\n\nlm_workflow\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow ════════════════════════════════════════════════════════════════════\nPreprocessor: None\nModel: linear_reg()\n\n── Model ───────────────────────────────────────────────────────────────────────\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n```\n\n\n:::\n:::\n\n\n::: callout-note\n`lm_workflow`中，`Preprocessor`为空，代表没有数据预处理。\n:::\n\n### 添加预处理器\n\n使用`add_formula`函数输入标准公式作为预处理器：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_workflow |>\n  add_formula(Sale_Price ~ Longitude + Latitude) -> lm_workflow\n\nlm_workflow\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow ════════════════════════════════════════════════════════════════════\nPreprocessor: Formula\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nSale_Price ~ Longitude + Latitude\n\n── Model ───────────────────────────────────────────────────────────────────────\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n```\n\n\n:::\n:::\n\n\n`workflow`对象可以使用`fit()`函数拟合模型，使用`predict()`函数进行预测。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_workflow |>\n  fit(data = ames_train) -> lm_fit\n\nlm_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow [trained] ══════════════════════════════════════════════════════════\nPreprocessor: Formula\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nSale_Price ~ Longitude + Latitude\n\n── Model ───────────────────────────────────────────────────────────────────────\n\nCall:\nstats::lm(formula = ..y ~ ., data = data)\n\nCoefficients:\n(Intercept)    Longitude     Latitude  \n   -300.251       -2.013        2.782  \n```\n\n\n:::\n\n```{.r .cell-code}\nlm_fit |>\n  predict(new_data = ames_test |>\n            slice(1:3)) # 预测\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 1\n  .pred\n  <dbl>\n1  5.22\n2  5.22\n3  5.28\n```\n\n\n:::\n:::\n\n\n可以使用`update_formula`函数更新预处理器：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_fit |>\n  update_formula(Sale_Price ~ Longitude)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow ════════════════════════════════════════════════════════════════════\nPreprocessor: Formula\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nSale_Price ~ Longitude\n\n── Model ───────────────────────────────────────────────────────────────────────\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n```\n\n\n:::\n:::\n\n\n### 添加变量\n\n使用`add_variables`函数添加变量。函数有两个参数：`outcomes`和`predictors`。支持使用`c()`函数添加多个变量。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_workflow |>\n  remove_formula() |>\n  add_variables(outcome = Sale_Price, predictors = c(Longitude, Latitude)) -> lm_workflow # 和上面的add_formula等价\n\nlm_workflow\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow ════════════════════════════════════════════════════════════════════\nPreprocessor: Variables\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nOutcomes: Sale_Price\nPredictors: c(Longitude, Latitude)\n\n── Model ───────────────────────────────────────────────────────────────────────\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n```\n\n\n:::\n:::\n\n\n拟合模型：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit(lm_workflow, data = ames_train) # 拟合模型\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow [trained] ══════════════════════════════════════════════════════════\nPreprocessor: Variables\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nOutcomes: Sale_Price\nPredictors: c(Longitude, Latitude)\n\n── Model ───────────────────────────────────────────────────────────────────────\n\nCall:\nstats::lm(formula = ..y ~ ., data = data)\n\nCoefficients:\n(Intercept)    Longitude     Latitude  \n   -300.251       -2.013        2.782  \n```\n\n\n:::\n:::\n\n\n### 为`workflow`使用公式\n\n#### 基于树的模型\n\n使用`Orthodont`数据集，拟合一个受试者具有随机效应的回归模型。\n\n在`workflow`中，使用`add_variables()`函数添加变量，使用`add_model()`函数添加模型。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(multilevelmod) # parsnip扩展包，主要用于多层次模型（混合效应模型、贝叶斯层次模型等）\n\ndata(Orthodont, package = \"nlme\")\n\nlinear_reg() |>\n  set_engine(\"lmer\") -> multilevel_spec # lmer是lme4包中的函数，用于拟合线性混合效应模型\n  \nworkflow() |>\n  add_variables(outcome = distance, predictors = c(Sex, age, Subject)) |> \n  add_model(multilevel_spec, \n            formula = distance ~ Sex + (age | Subject)) -> multilevel_workflow # age | Subject表示age是Subject的随机效应\n\nmultilevel_workflow |>\n  fit(data = Orthodont) -> multilevel_fit\n\nmultilevel_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow [trained] ══════════════════════════════════════════════════════════\nPreprocessor: Variables\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nOutcomes: distance\nPredictors: c(Sex, age, Subject)\n\n── Model ───────────────────────────────────────────────────────────────────────\nLinear mixed model fit by REML ['lmerMod']\nFormula: distance ~ Sex + (age | Subject)\n   Data: data\nREML criterion at convergence: 471.1635\nRandom effects:\n Groups   Name        Std.Dev. Corr \n Subject  (Intercept) 7.3912        \n          age         0.6943   -0.97\n Residual             1.3100        \nNumber of obs: 108, groups:  Subject, 27\nFixed Effects:\n(Intercept)    SexFemale  \n     24.517       -2.145  \n```\n\n\n:::\n:::\n\n\n可以进一步使用`survival`包中的`strata`函数进行生存分析.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(censored) # parsnip扩展包，主要用于删减回归和生存分析模型\n\nsurvival_reg() -> parametric_spec\n\ndata(cancer, package = \"survival\")\n\nworkflow() |>\n  add_variables(outcome = c(fustat, futime), predictors = c(age, rx)) |>\n  add_model(parametric_spec, \n            formula = Surv(futime, fustat) ~ age + strata(rx)) -> parametric_workflow\n\nparametric_workflow |>\n  fit(data = ovarian) -> parametric_fit\n\nparametric_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow [trained] ══════════════════════════════════════════════════════════\nPreprocessor: Variables\nModel: survival_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nOutcomes: c(fustat, futime)\nPredictors: c(age, rx)\n\n── Model ───────────────────────────────────────────────────────────────────────\nCall:\nsurvival::survreg(formula = Surv(futime, fustat) ~ age + strata(rx), \n    data = data, model = TRUE)\n\nCoefficients:\n(Intercept)         age \n 12.8734120  -0.1033569 \n\nScale:\n     rx=1      rx=2 \n0.7695509 0.4703602 \n\nLoglik(model)= -89.4   Loglik(intercept only)= -97.1\n\tChisq= 15.36 on 1 degrees of freedom, p= 8.88e-05 \nn= 26 \n```\n\n\n:::\n:::\n\n\n### 同时创建多个workflow\n\n做预测模型时，一般需要评估多个不同的模型。例如**筛选预测因子**。可以创建一组`formula`来罗列不同的预测因子组合。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(\n  longitude = Sale_Price ~ Longitude,\n  latitude = Sale_Price ~ Latitude,\n  coords = Sale_Price ~ Longitude + Latitude,\n  neighborhood = Sale_Price ~ Neighborhood) -> location\n```\n:::\n\n\n使用`workflow_set()`函数创建一个`workflow`集合。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworkflow_set(preproc = location, models = list(lm = lm_model)) -> location_models\n\nlocation_models\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A workflow set/tibble: 4 × 4\n  wflow_id        info             option    result    \n  <chr>           <list>           <list>    <list>    \n1 longitude_lm    <tibble [1 × 4]> <opts[0]> <list [0]>\n2 latitude_lm     <tibble [1 × 4]> <opts[0]> <list [0]>\n3 coords_lm       <tibble [1 × 4]> <opts[0]> <list [0]>\n4 neighborhood_lm <tibble [1 × 4]> <opts[0]> <list [0]>\n```\n\n\n:::\n\n```{.r .cell-code}\nlocation_models$info[[1]] # 查看第一个workflow的信息\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 4\n  workflow   preproc model      comment\n  <list>     <chr>   <chr>      <chr>  \n1 <workflow> formula linear_reg \"\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nextract_workflow(location_models, id = \"coords_lm\") # 提取一个workflow\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow ════════════════════════════════════════════════════════════════════\nPreprocessor: Formula\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nSale_Price ~ Longitude + Latitude\n\n── Model ───────────────────────────────────────────────────────────────────────\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n```\n\n\n:::\n:::\n\n\n为每个`formula`创建`fit`对象：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocation_models |>\n  mutate(fit = map(info, ~ fit(.x$workflow[[1]], ames_train))) -> location_models # 使用map函数对每个workflow进行拟合\n\nlocation_models\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A workflow set/tibble: 4 × 5\n  wflow_id        info             option    result     fit       \n  <chr>           <list>           <list>    <list>     <list>    \n1 longitude_lm    <tibble [1 × 4]> <opts[0]> <list [0]> <workflow>\n2 latitude_lm     <tibble [1 × 4]> <opts[0]> <list [0]> <workflow>\n3 coords_lm       <tibble [1 × 4]> <opts[0]> <list [0]> <workflow>\n4 neighborhood_lm <tibble [1 × 4]> <opts[0]> <list [0]> <workflow>\n```\n\n\n:::\n\n```{.r .cell-code}\nlocation_models$fit[[1]] # 查看第一个workflow的拟合结果\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow [trained] ══════════════════════════════════════════════════════════\nPreprocessor: Formula\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nSale_Price ~ Longitude\n\n── Model ───────────────────────────────────────────────────────────────────────\n\nCall:\nstats::lm(formula = ..y ~ ., data = data)\n\nCoefficients:\n(Intercept)    Longitude  \n    -176.46        -1.94  \n```\n\n\n:::\n:::\n\n\n### 评估测试集\n\n使用`last_fit`函数，可以把模型拟合到整个训练集，然后评估测试集。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlast_fit(lm_workflow, ames_split) -> final_lm_res # 用法：last_fit(模型, 数据分割)\n\nfinal_lm_res\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Resampling results\n# Manual resampling \n# A tibble: 1 × 6\n  splits             id               .metrics .notes   .predictions .workflow \n  <list>             <chr>            <list>   <list>   <list>       <list>    \n1 <split [2342/588]> train/test split <tibble> <tibble> <tibble>     <workflow>\n```\n\n\n:::\n\n```{.r .cell-code}\nfinal_lm_res |>\n  extract_workflow() # 提取workflow\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow [trained] ══════════════════════════════════════════════════════════\nPreprocessor: Variables\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nOutcomes: Sale_Price\nPredictors: c(Longitude, Latitude)\n\n── Model ───────────────────────────────────────────────────────────────────────\n\nCall:\nstats::lm(formula = ..y ~ ., data = data)\n\nCoefficients:\n(Intercept)    Longitude     Latitude  \n   -300.251       -2.013        2.782  \n```\n\n\n:::\n\n```{.r .cell-code}\nfinal_lm_res |>\n  collect_metrics() # 收集模型评估指标\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 4\n  .metric .estimator .estimate .config             \n  <chr>   <chr>          <dbl> <chr>               \n1 rmse    standard       0.160 Preprocessor1_Model1\n2 rsq     standard       0.208 Preprocessor1_Model1\n```\n\n\n:::\n\n```{.r .cell-code}\nfinal_lm_res |>\n  collect_predictions() |> # 收集预测结果\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  id               .pred  .row Sale_Price .config             \n  <chr>            <dbl> <int>      <dbl> <chr>               \n1 train/test split  5.22     2       5.02 Preprocessor1_Model1\n2 train/test split  5.22     3       5.24 Preprocessor1_Model1\n3 train/test split  5.28     5       5.28 Preprocessor1_Model1\n4 train/test split  5.24    28       5.06 Preprocessor1_Model1\n5 train/test split  5.31    39       5.60 Preprocessor1_Model1\n6 train/test split  5.31    44       5.33 Preprocessor1_Model1\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "tidymodels_files\\figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}