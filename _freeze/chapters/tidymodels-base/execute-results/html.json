{
  "hash": "fdee182ccd5e8e023f6f1ec632c8ea00",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"tidymodels\"\nauthor: \"一把Fei刀\"\ndate: 2024-2-5\ndate-modified: last-modified\nnumber-sections: true\n---\n\n\n> 本篇是tidymodels包的学习笔记，主要参考文档是[Tidy Modeling with R](https://www.tmwr.org/)。\n\n\n\n\n\n## 建模基础\n\n\n```{mermaid}\n%%| echo: false\n---\ntitle: 建模的分类\n---\nflowchart LR\nA[模型] --- B[描述性模型]\nA --- C[推理模型]\nA --- D[预测模型]\nD --- E[无监督模型]\nD --- F[监督模型]\nE --- G[\"主成分分析(PCA)\"]\nE --- H[聚类]\nE --- I[自动编码器]\nF --- J[回归]\nF --- K[神经网络]\n```\n\n```{mermaid}\n%%| echo: false\n---\ntitle: 模型建模的一般步骤\n---\nflowchart LR\nA[导入数据] --> B[\"清洗数据(tidy)\"] ---> C[\"探索性数据分析(EDA)\"] --> D[特征工程] --> E[建模与优化] --> F[评估] --> G[部署]\nF -.-> C\n```\n\n\n## 练习数据和探索性数据分析\n\n练习数据使用的是`modeldata`包中的`ames`数据集。数据集包括：\n\n-   房屋特征house characteristics，如bedrooms, garage, fireplace, pool, porch等；\n-   区位location；\n-   地块信息lot information，如zoning, shape, size等；\n-   条件和质量评级ratings of condition and quality；\n-   成交价格sale price。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(ames)\ndim(ames)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2930   74\n```\n\n\n:::\n:::\n\n\n### 探索性数据分析-探索住宅特点\n\n首先关注房屋的最终销售价格（美元）。使用直方图来查看销售价格的分布情况，如 @fig-0201 所示。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidymodels_prefer() # 用于处理包之间的函数冲突，不会输出结果\n\names |>\n  ggplot(aes(x = Sale_Price)) +\n  geom_histogram(bins = 50, col = \"white\") +\n  theme_bw() -> fig_0201\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfig_0201\n```\n\n::: {.cell-output-display}\n![销售价格（美元）](tidymodels-base_files/figure-html/fig-0201-1.png){#fig-0201 width=672}\n:::\n:::\n\n\n作图发现数据是偏态的，可以使用对数变换来处理。这种转换的优点是，不会预测出负销售价格的房屋，而且预测昂贵房屋的误差也不会对模型产生过大的影响。另外，对数变换还可以稳定方差，使得模型更容易拟合。结果如 @fig-0202 所示。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfig_0201 +\n  scale_x_log10() -> fig_0202\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfig_0202\n```\n\n::: {.cell-output-display}\n![对数变换后的销售价格（美元）](tidymodels-base_files/figure-html/fig-0202-1.png){#fig-0202 width=672}\n:::\n:::\n\n\n::: callout-caution\n对数转换结果的主要缺点涉及到对**模型结果**的解释。在对数变换后，模型的系数不再是直接解释的，而是对数解释。这意味着，模型的系数是对数销售价格的变化，而不是销售价格的变化。这种情况下，需要小心解释模型的结果。\n:::\n\n对数转换的结果相对较好，因此可以使用对数转换后的销售价格作为目标变量。\n\n\n::: {.cell}\n\n```{.r .cell-code}\names |>\n  mutate(Sale_Price = log10(Sale_Price)) -> ames\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n## 数据分割\n\n\n::: {.cell}\n\n:::\n\n\n一般会将数据集分为训练集和测试集。训练集用于拟合模型，测试集用于评估模型的性能。\n\n测试集只能使用一次，否则就会成为建模过程的一部分。这样会导致模型在测试集上的性能过于乐观，无法真实地评估模型的性能。\n\n### 简单随机抽样\n\n在`tidymodels`中，可以使用`initial_split()`函数来分割数据集。默认情况下，`initial_split()`函数会将数据集分为80%的训练集和20%的测试集。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\names_split <- initial_split(ames, prop = 0.8)\n\names_split\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<Training/Testing/Total>\n<2344/586/2930>\n```\n\n\n:::\n:::\n\n\n`ames_split`是一个`rsplit`对象，仅包含分区信息，可以使用`training()`和`testing()`函数来提取训练集和测试集。\n\n\n::: {.cell}\n\n```{.r .cell-code}\names_train <- training(ames_split)\names_test <- testing(ames_split)\n\ndim(ames_train)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2344   74\n```\n\n\n:::\n:::\n\n\n### 分层抽样\n\n在某些情况下，需要使用分层抽样。例如，如果数据集中有一个重要的类别变量，那么就需要使用分层抽样来确保训练集和测试集中都包含这个类别变量的各个水平。\n\n可以人为地将结果数据四等分，然后分别进行四次分层抽样，这样可以保持训练集和测试集的分布一致。\n\n\n::: {.cell}\n\n```{.r .cell-code}\names |>\n  pull(Sale_Price) |> # 提取销售价格\n  density(n = 2^10) |> # 生成密度估计\n  tidy() -> sale_dens # 将结果转换为数据框\n\ntibble(prob = (1:3)/4, value = quantile(ames$Sale_Price, probs = prob)) |> # 计算四分位数\n  mutate(y = approx(sale_dens$x, sale_dens$y, xout = value)$y) -> quartiles # 计算四分位数的密度值\n\names |>\n  ggplot(aes(x = Sale_Price)) +\n  geom_line(stat = \"density\") +\n  geom_segment(data = quartiles,\n               aes(x = value, xend = value, y = 0, yend = y),\n               lty = 2) +\n  labs(x = \"Sale Price (log-10 USD)\", y = NULL) +\n  theme_bw() -> fig_0203\nfig_0203\n```\n\n::: {.cell-output-display}\n![房屋销售价格分布(log)，虚线代表四分位数](tidymodels-base_files/figure-html/fig-0203-1.png){#fig-0203 width=672}\n:::\n:::\n\n\n销售价格的分布呈右偏态，廉价房屋的比例更大。因此，可以使用分层抽样来确保训练集和测试集中都包含廉价房屋。可以使用`strata`参数来指定分层变量。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\names_split <- initial_split(ames, prop = 0.80, strata = Sale_Price)\names_train <- training(ames_split)\names_test  <-  testing(ames_split)\n\ndim(ames_train)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2342   74\n```\n\n\n:::\n:::\n\n\n::: callout-caution\n只能使用单列作为分层变量，不能使用多列。\n:::\n\n### 交叉验证-验证集的分割\n\n交叉验证通常用于解决模型过拟合的问题。为此，可以把数据集分为训练集、测试集和验证集，其中验证集用于调整模型的超参数。可以用`initial_vadilation_split()`函数来实现。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\names_val_split <- initial_validation_split(ames, prop = c(0.6, 0.2))\n\names_val_split\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<Training/Validation/Testing/Total>\n<1758/586/586/2930>\n```\n\n\n:::\n\n```{.r .cell-code}\names_val_train <- training(ames_val_split)\names_val_test  <- testing(ames_val_split)\names_val_val   <- validation(ames_val_split)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n## 模型拟合-以线性回归为例\n\n\n::: {.cell}\n\n:::\n\n\n对于一些相对简单的模型，可以使用`parsnip`包中的`fit`和`predict`函数来拟合和预测。`parsnip`包提供了统一的接口，可以使用相同的函数来拟合不同的模型。\n\n使用`parsnip`中的`linear_reg()`函数指定模型类型，`set_engine()`函数指定模型引擎，这里的引擎一般指的是具体建模使用的软件包名称。确定模型后，可以使用`fit()`函数或`fit_xy()`函数来拟合模型。以三种常用的线性回归模型为例。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlinear_reg() |>\n  set_engine(\"lm\") |>\n  translate()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n\nModel fit template:\nstats::lm(formula = missing_arg(), data = missing_arg(), weights = missing_arg())\n```\n\n\n:::\n\n```{.r .cell-code}\nlinear_reg(penalty = 1) |> # panalty是glmnet的特有参数\n  set_engine(\"glmnet\") |>\n  translate()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear Regression Model Specification (regression)\n\nMain Arguments:\n  penalty = 1\n\nComputational engine: glmnet \n\nModel fit template:\nglmnet::glmnet(x = missing_arg(), y = missing_arg(), weights = missing_arg(), \n    family = \"gaussian\")\n```\n\n\n:::\n\n```{.r .cell-code}\nlinear_reg() |>\n  set_engine(\"stan\") |>\n  translate()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear Regression Model Specification (regression)\n\nComputational engine: stan \n\nModel fit template:\nrstanarm::stan_glm(formula = missing_arg(), data = missing_arg(), \n    weights = missing_arg(), family = stats::gaussian, refresh = 0)\n```\n\n\n:::\n:::\n\n\n> `translate()`函数可以提供模型转换的详细参数信息。\\\n> `missing_arg()`是占位符，表示数据未提供。\n\n以经度和纬度为自变量，销售价格为因变量，拟合线性回归模型。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlinear_reg() |>\n  set_engine(\"lm\") -> lm_model\n\nlm_model |>\n  fit(Sale_Price ~ Longitude + Latitude, data = ames_train) -> lm_form_fit\n\nlm_model |>\n  fit_xy(x = ames_train |>\n           select(Longitude, Latitude),\n         y = ames_train |>\n           pull(Sale_Price)\n  ) -> lm_xy_fit\n\nlm_form_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nparsnip model object\n\n\nCall:\nstats::lm(formula = Sale_Price ~ Longitude + Latitude, data = data)\n\nCoefficients:\n(Intercept)    Longitude     Latitude  \n   -300.251       -2.013        2.782  \n```\n\n\n:::\n\n```{.r .cell-code}\nlm_xy_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nparsnip model object\n\n\nCall:\nstats::lm(formula = ..y ~ ., data = data)\n\nCoefficients:\n(Intercept)    Longitude     Latitude  \n   -300.251       -2.013        2.782  \n```\n\n\n:::\n:::\n\n\n## 提取模型结果\n\n`lm_form_fit`和`lm_xy_fit`是`parsnip`模型对象，拟合模型储存在`fit`属性中。可以使用`extract_fit_engine()`函数提取拟合模型。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_form_fit |>\n  tidy() # 最简单的提取模型系数的方法（提取为tibble）\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n  term        estimate std.error statistic  p.value\n  <chr>          <dbl>     <dbl>     <dbl>    <dbl>\n1 (Intercept)  -300.      14.6       -20.6 1.02e-86\n2 Longitude      -2.01     0.130     -15.5 8.13e-52\n3 Latitude        2.78     0.182      15.3 1.64e-50\n```\n\n\n:::\n\n```{.r .cell-code}\nlm_form_fit |>\n  extract_fit_engine() |> # 提取模型\n  vcov() # 提取模型的协方差矩阵\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            (Intercept)     Longitude      Latitude\n(Intercept)  212.620590  1.6113032179 -1.4686377363\nLongitude      1.611303  0.0168165968 -0.0008694728\nLatitude      -1.468638 -0.0008694728  0.0330018995\n```\n\n\n:::\n\n```{.r .cell-code}\nlm_form_fit |>\n  extract_fit_engine() |>\n  summary() |> # 提取模型的摘要信息\n  coef() # 提取模型的系数\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               Estimate Std. Error   t value     Pr(>|t|)\n(Intercept) -300.250929 14.5815154 -20.59120 1.022609e-86\nLongitude     -2.013413  0.1296788 -15.52615 8.126177e-52\nLatitude       2.781713  0.1816642  15.31239 1.639312e-50\n```\n\n\n:::\n\n```{.r .cell-code}\nlm_form_fit |>\n  extract_fit_engine() |>\n  gtsummary::tbl_regression() # 生成模型摘要信息\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"nhnzqqzgeq\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>#nhnzqqzgeq table {\n  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n#nhnzqqzgeq thead, #nhnzqqzgeq tbody, #nhnzqqzgeq tfoot, #nhnzqqzgeq tr, #nhnzqqzgeq td, #nhnzqqzgeq th {\n  border-style: none;\n}\n\n#nhnzqqzgeq p {\n  margin: 0;\n  padding: 0;\n}\n\n#nhnzqqzgeq .gt_table {\n  display: table;\n  border-collapse: collapse;\n  line-height: normal;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_caption {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n#nhnzqqzgeq .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#nhnzqqzgeq .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 3px;\n  padding-bottom: 5px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#nhnzqqzgeq .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#nhnzqqzgeq .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#nhnzqqzgeq .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#nhnzqqzgeq .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#nhnzqqzgeq .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#nhnzqqzgeq .gt_spanner_row {\n  border-bottom-style: hidden;\n}\n\n#nhnzqqzgeq .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  text-align: left;\n}\n\n#nhnzqqzgeq .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#nhnzqqzgeq .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#nhnzqqzgeq .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#nhnzqqzgeq .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#nhnzqqzgeq .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#nhnzqqzgeq .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#nhnzqqzgeq .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#nhnzqqzgeq .gt_row_group_first th {\n  border-top-width: 2px;\n}\n\n#nhnzqqzgeq .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#nhnzqqzgeq .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#nhnzqqzgeq .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#nhnzqqzgeq .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_last_grand_summary_row_top {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: double;\n  border-bottom-width: 6px;\n  border-bottom-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#nhnzqqzgeq .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#nhnzqqzgeq .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#nhnzqqzgeq .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#nhnzqqzgeq .gt_left {\n  text-align: left;\n}\n\n#nhnzqqzgeq .gt_center {\n  text-align: center;\n}\n\n#nhnzqqzgeq .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#nhnzqqzgeq .gt_font_normal {\n  font-weight: normal;\n}\n\n#nhnzqqzgeq .gt_font_bold {\n  font-weight: bold;\n}\n\n#nhnzqqzgeq .gt_font_italic {\n  font-style: italic;\n}\n\n#nhnzqqzgeq .gt_super {\n  font-size: 65%;\n}\n\n#nhnzqqzgeq .gt_footnote_marks {\n  font-size: 75%;\n  vertical-align: 0.4em;\n  position: initial;\n}\n\n#nhnzqqzgeq .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#nhnzqqzgeq .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#nhnzqqzgeq .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#nhnzqqzgeq .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#nhnzqqzgeq .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#nhnzqqzgeq .gt_indent_5 {\n  text-indent: 25px;\n}\n</style>\n<table class=\"gt_table\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n  <thead>\n    \n    <tr class=\"gt_col_headings\">\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"&lt;strong&gt;Characteristic&lt;/strong&gt;\"><strong>Characteristic</strong></th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_center\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"&lt;strong&gt;Beta&lt;/strong&gt;\"><strong>Beta</strong></th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_center\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"&lt;strong&gt;95% CI&lt;/strong&gt;&lt;span class=&quot;gt_footnote_marks&quot; style=&quot;white-space:nowrap;font-style:italic;font-weight:normal;&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/span&gt;\"><strong>95% CI</strong><span class=\"gt_footnote_marks\" style=\"white-space:nowrap;font-style:italic;font-weight:normal;\"><sup>1</sup></span></th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_center\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"&lt;strong&gt;p-value&lt;/strong&gt;\"><strong>p-value</strong></th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td headers=\"label\" class=\"gt_row gt_left\">Longitude</td>\n<td headers=\"estimate\" class=\"gt_row gt_center\">-2.0</td>\n<td headers=\"ci\" class=\"gt_row gt_center\">-2.3, -1.8</td>\n<td headers=\"p.value\" class=\"gt_row gt_center\"><0.001</td></tr>\n    <tr><td headers=\"label\" class=\"gt_row gt_left\">Latitude</td>\n<td headers=\"estimate\" class=\"gt_row gt_center\">2.8</td>\n<td headers=\"ci\" class=\"gt_row gt_center\">2.4, 3.1</td>\n<td headers=\"p.value\" class=\"gt_row gt_center\"><0.001</td></tr>\n  </tbody>\n  \n  <tfoot class=\"gt_footnotes\">\n    <tr>\n      <td class=\"gt_footnote\" colspan=\"4\"><span class=\"gt_footnote_marks\" style=\"white-space:nowrap;font-style:italic;font-weight:normal;\"><sup>1</sup></span> CI = Confidence Interval</td>\n    </tr>\n  </tfoot>\n</table>\n</div>\n```\n\n:::\n:::\n\n\n## 模型预测\n\n使用`predict()`函数进行预测。\n\n\n::: {.cell}\n\n```{.r .cell-code}\names_test |>\n  slice(1:5) -> ames_test_small # 选择前五行数据\n\npredict(lm_form_fit, new_data = ames_test_small) # 预测结果\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 1\n  .pred\n  <dbl>\n1  5.22\n2  5.22\n3  5.28\n4  5.24\n5  5.31\n```\n\n\n:::\n\n```{.r .cell-code}\names_test_small |>\n  select(Sale_Price) |> # 真实值\n  bind_cols(predict(lm_form_fit, ames_test_small)) |> # 预测值\n  bind_cols(predict(lm_form_fit, ames_test_small, type = \"pred_int\")) # 预测区间\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n  Sale_Price .pred .pred_lower .pred_upper\n       <dbl> <dbl>       <dbl>       <dbl>\n1       5.02  5.22        4.91        5.54\n2       5.24  5.22        4.91        5.54\n3       5.28  5.28        4.97        5.60\n4       5.06  5.24        4.92        5.56\n5       5.60  5.31        5.00        5.63\n```\n\n\n:::\n:::\n\n\n以决策树为例，对数据进行建模\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndecision_tree(min_n = 2) |>\n  set_engine(\"rpart\") |>\n  set_mode(\"regression\") -> tree_model\n\ntree_model |>\n  fit(Sale_Price ~ Longitude + Latitude, data = ames_train) -> tree_fit\n\names_test_small |>\n  select(Sale_Price) |> # 真实值\n  bind_cols(predict(tree_fit, ames_test_small)) # 预测值\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  Sale_Price .pred\n       <dbl> <dbl>\n1       5.02  5.15\n2       5.24  5.15\n3       5.28  5.31\n4       5.06  5.15\n5       5.60  5.52\n```\n\n\n:::\n:::\n\n\n::: callout-important\n可以在<https://www.tidymodels.org/find/>找所有可用的模型。\n\n`parsnip_addin()`函数可以在RStudio中搜索模型。\n:::\n\n\n::: {.cell}\n\n:::\n\n\n## workflow\n\n### 创建workflow对象\n\n使用`lm_model`来创建`workflow`对象，`workflow`对象可以将数据预处理和模型拟合整合在一起。\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlinear_reg() |>\n  set_engine(\"lm\") -> lm_workflow\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nworkflow() |>\n  add_model(lm_model) -> lm_workflow\n\nlm_workflow\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow ════════════════════════════════════════════════════════════════════\nPreprocessor: None\nModel: linear_reg()\n\n── Model ───────────────────────────────────────────────────────────────────────\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n```\n\n\n:::\n:::\n\n\n::: callout-note\n`lm_workflow`中，`Preprocessor`为空，代表没有数据预处理。\n:::\n\n### 添加预处理器\n\n使用`add_formula`函数输入标准公式作为预处理器：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_workflow |>\n  add_formula(Sale_Price ~ Longitude + Latitude) -> lm_workflow\n\nlm_workflow\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow ════════════════════════════════════════════════════════════════════\nPreprocessor: Formula\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nSale_Price ~ Longitude + Latitude\n\n── Model ───────────────────────────────────────────────────────────────────────\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n```\n\n\n:::\n:::\n\n\n`workflow`对象可以使用`fit()`函数拟合模型，使用`predict()`函数进行预测。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_workflow |>\n  fit(data = ames_train) -> lm_fit\n\nlm_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow [trained] ══════════════════════════════════════════════════════════\nPreprocessor: Formula\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nSale_Price ~ Longitude + Latitude\n\n── Model ───────────────────────────────────────────────────────────────────────\n\nCall:\nstats::lm(formula = ..y ~ ., data = data)\n\nCoefficients:\n(Intercept)    Longitude     Latitude  \n   -300.251       -2.013        2.782  \n```\n\n\n:::\n\n```{.r .cell-code}\nlm_fit |>\n  predict(new_data = ames_test |>\n            slice(1:3)) # 预测\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 1\n  .pred\n  <dbl>\n1  5.22\n2  5.22\n3  5.28\n```\n\n\n:::\n:::\n\n\n可以使用`update_formula`函数更新预处理器：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_fit |>\n  update_formula(Sale_Price ~ Longitude)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow ════════════════════════════════════════════════════════════════════\nPreprocessor: Formula\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nSale_Price ~ Longitude\n\n── Model ───────────────────────────────────────────────────────────────────────\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n```\n\n\n:::\n:::\n\n\n### 添加变量\n\n使用`add_variables`函数添加变量。函数有两个参数：`outcomes`和`predictors`。支持使用`c()`函数添加多个变量。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_workflow |>\n  remove_formula() |>\n  add_variables(outcome = Sale_Price, predictors = c(Longitude, Latitude)) -> lm_workflow # 和上面的add_formula等价\n\nlm_workflow\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow ════════════════════════════════════════════════════════════════════\nPreprocessor: Variables\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nOutcomes: Sale_Price\nPredictors: c(Longitude, Latitude)\n\n── Model ───────────────────────────────────────────────────────────────────────\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n```\n\n\n:::\n:::\n\n\n拟合模型：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit(lm_workflow, data = ames_train) # 拟合模型\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow [trained] ══════════════════════════════════════════════════════════\nPreprocessor: Variables\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nOutcomes: Sale_Price\nPredictors: c(Longitude, Latitude)\n\n── Model ───────────────────────────────────────────────────────────────────────\n\nCall:\nstats::lm(formula = ..y ~ ., data = data)\n\nCoefficients:\n(Intercept)    Longitude     Latitude  \n   -300.251       -2.013        2.782  \n```\n\n\n:::\n:::\n\n\n### 为`workflow`使用公式\n\n#### 基于树的模型\n\n使用`Orthodont`数据集，拟合一个受试者具有随机效应的回归模型。\n\n在`workflow`中，使用`add_variables()`函数添加变量，使用`add_model()`函数添加模型。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(multilevelmod) # parsnip扩展包，主要用于多层次模型（混合效应模型、贝叶斯层次模型等）\n\ndata(Orthodont, package = \"nlme\")\n\nlinear_reg() |>\n  set_engine(\"lmer\") -> multilevel_spec # lmer是lme4包中的函数，用于拟合线性混合效应模型\n  \nworkflow() |>\n  add_variables(outcome = distance, predictors = c(Sex, age, Subject)) |> \n  add_model(multilevel_spec, \n            formula = distance ~ Sex + (age | Subject)) -> multilevel_workflow # age | Subject表示age是Subject的随机效应\n\nmultilevel_workflow |>\n  fit(data = Orthodont) -> multilevel_fit\n\nmultilevel_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow [trained] ══════════════════════════════════════════════════════════\nPreprocessor: Variables\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nOutcomes: distance\nPredictors: c(Sex, age, Subject)\n\n── Model ───────────────────────────────────────────────────────────────────────\nLinear mixed model fit by REML ['lmerMod']\nFormula: distance ~ Sex + (age | Subject)\n   Data: data\nREML criterion at convergence: 471.1635\nRandom effects:\n Groups   Name        Std.Dev. Corr \n Subject  (Intercept) 7.3912        \n          age         0.6943   -0.97\n Residual             1.3100        \nNumber of obs: 108, groups:  Subject, 27\nFixed Effects:\n(Intercept)    SexFemale  \n     24.517       -2.145  \n```\n\n\n:::\n:::\n\n\n可以进一步使用`survival`包中的`strata`函数进行生存分析.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(censored) # parsnip扩展包，主要用于删减回归和生存分析模型\n\nsurvival_reg() -> parametric_spec\n\ndata(cancer, package = \"survival\")\n\nworkflow() |>\n  add_variables(outcome = c(fustat, futime), predictors = c(age, rx)) |>\n  add_model(parametric_spec, \n            formula = Surv(futime, fustat) ~ age + strata(rx)) -> parametric_workflow\n\nparametric_workflow |>\n  fit(data = ovarian) -> parametric_fit\n\nparametric_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow [trained] ══════════════════════════════════════════════════════════\nPreprocessor: Variables\nModel: survival_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nOutcomes: c(fustat, futime)\nPredictors: c(age, rx)\n\n── Model ───────────────────────────────────────────────────────────────────────\nCall:\nsurvival::survreg(formula = Surv(futime, fustat) ~ age + strata(rx), \n    data = data, model = TRUE)\n\nCoefficients:\n(Intercept)         age \n 12.8734120  -0.1033569 \n\nScale:\n     rx=1      rx=2 \n0.7695509 0.4703602 \n\nLoglik(model)= -89.4   Loglik(intercept only)= -97.1\n\tChisq= 15.36 on 1 degrees of freedom, p= 8.88e-05 \nn= 26 \n```\n\n\n:::\n:::\n\n\n### 同时创建多个workflow\n\n做预测模型时，一般需要评估多个不同的模型。例如**筛选预测因子**。可以创建一组`formula`来罗列不同的预测因子组合。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(\n  longitude = Sale_Price ~ Longitude,\n  latitude = Sale_Price ~ Latitude,\n  coords = Sale_Price ~ Longitude + Latitude,\n  neighborhood = Sale_Price ~ Neighborhood) -> location\n```\n:::\n\n\n使用`workflow_set()`函数创建一个`workflow`集合。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworkflow_set(preproc = location, models = list(lm = lm_model)) -> location_models\n\nlocation_models\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A workflow set/tibble: 4 × 4\n  wflow_id        info             option    result    \n  <chr>           <list>           <list>    <list>    \n1 longitude_lm    <tibble [1 × 4]> <opts[0]> <list [0]>\n2 latitude_lm     <tibble [1 × 4]> <opts[0]> <list [0]>\n3 coords_lm       <tibble [1 × 4]> <opts[0]> <list [0]>\n4 neighborhood_lm <tibble [1 × 4]> <opts[0]> <list [0]>\n```\n\n\n:::\n\n```{.r .cell-code}\nlocation_models$info[[1]] # 查看第一个workflow的信息\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 4\n  workflow   preproc model      comment\n  <list>     <chr>   <chr>      <chr>  \n1 <workflow> formula linear_reg \"\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nextract_workflow(location_models, id = \"coords_lm\") # 提取一个workflow\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow ════════════════════════════════════════════════════════════════════\nPreprocessor: Formula\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nSale_Price ~ Longitude + Latitude\n\n── Model ───────────────────────────────────────────────────────────────────────\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n```\n\n\n:::\n:::\n\n\n为每个`formula`创建`fit`对象：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocation_models |>\n  mutate(fit = map(info, ~ fit(.x$workflow[[1]], ames_train))) -> location_models # 使用map函数对每个workflow进行拟合\n\nlocation_models\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A workflow set/tibble: 4 × 5\n  wflow_id        info             option    result     fit       \n  <chr>           <list>           <list>    <list>     <list>    \n1 longitude_lm    <tibble [1 × 4]> <opts[0]> <list [0]> <workflow>\n2 latitude_lm     <tibble [1 × 4]> <opts[0]> <list [0]> <workflow>\n3 coords_lm       <tibble [1 × 4]> <opts[0]> <list [0]> <workflow>\n4 neighborhood_lm <tibble [1 × 4]> <opts[0]> <list [0]> <workflow>\n```\n\n\n:::\n\n```{.r .cell-code}\nlocation_models$fit[[1]] # 查看第一个workflow的拟合结果\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow [trained] ══════════════════════════════════════════════════════════\nPreprocessor: Formula\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nSale_Price ~ Longitude\n\n── Model ───────────────────────────────────────────────────────────────────────\n\nCall:\nstats::lm(formula = ..y ~ ., data = data)\n\nCoefficients:\n(Intercept)    Longitude  \n    -176.46        -1.94  \n```\n\n\n:::\n:::\n\n\n### 评估测试集\n\n使用`last_fit`函数，可以把模型拟合到整个训练集，然后评估测试集。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlast_fit(lm_workflow, ames_split) -> final_lm_res # 用法：last_fit(模型, 数据分割)\n\nfinal_lm_res\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Resampling results\n# Manual resampling \n# A tibble: 1 × 6\n  splits             id               .metrics .notes   .predictions .workflow \n  <list>             <chr>            <list>   <list>   <list>       <list>    \n1 <split [2342/588]> train/test split <tibble> <tibble> <tibble>     <workflow>\n```\n\n\n:::\n\n```{.r .cell-code}\nfinal_lm_res |>\n  extract_workflow() # 提取workflow\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow [trained] ══════════════════════════════════════════════════════════\nPreprocessor: Variables\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\nOutcomes: Sale_Price\nPredictors: c(Longitude, Latitude)\n\n── Model ───────────────────────────────────────────────────────────────────────\n\nCall:\nstats::lm(formula = ..y ~ ., data = data)\n\nCoefficients:\n(Intercept)    Longitude     Latitude  \n   -300.251       -2.013        2.782  \n```\n\n\n:::\n\n```{.r .cell-code}\nfinal_lm_res |>\n  collect_metrics() # 收集模型评估指标\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 4\n  .metric .estimator .estimate .config             \n  <chr>   <chr>          <dbl> <chr>               \n1 rmse    standard       0.160 Preprocessor1_Model1\n2 rsq     standard       0.208 Preprocessor1_Model1\n```\n\n\n:::\n\n```{.r .cell-code}\nfinal_lm_res |>\n  collect_predictions() |> # 收集预测结果\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  id               .pred  .row Sale_Price .config             \n  <chr>            <dbl> <int>      <dbl> <chr>               \n1 train/test split  5.22     2       5.02 Preprocessor1_Model1\n2 train/test split  5.22     3       5.24 Preprocessor1_Model1\n3 train/test split  5.28     5       5.28 Preprocessor1_Model1\n4 train/test split  5.24    28       5.06 Preprocessor1_Model1\n5 train/test split  5.31    39       5.60 Preprocessor1_Model1\n6 train/test split  5.31    44       5.33 Preprocessor1_Model1\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n## 特征工程\n\n\n::: {.cell}\n\n:::\n\n\n特征工程指对预测值进行重新格式化，使其更容易被模型有效利用。特征工程的方法一般分为以下几种：\n\n1. **dummy**，哑变量，将分类变量分为多个哑变量（0-1变量）。\n2. **zv**， zero variance，删除方差为0的变量，也就是只有单一值的变量。\n3. **impute**，估算，填补缺失值。\n4. **decorrelate**，去相关，删除相关性较高的变量。一般使用PCA方法或者VIF方法。\n5. **normalize**，标准化，将变量居中并缩放到单位方差。\n6. **transform**，转换，将变量转换成更对称的分布。\n\n使用`recipe`包可以把不同的特征工程方法组合在一起，并应用到数据集上。\n\n### 创建特征工程\n\n从`ames`数据集中挑选以下预测因子：\n\n1. `Neighborhood`，分类变量，指房屋所在的社区，有29个水平。\n2. `Gr_Liv_Area`，数值变量，指房屋的居住面积。\n3. `Year_Built`，数值变量，指房屋建造的年份。\n4. `Bldg_Type`，分类变量，指房屋的类型，有5个水平，分别是`OneFam`，`TwoFmCon`，`Duplex`，`Twnhs`，`TwnhsE`。\n\n使用这些预测因子对`Sale_Price`进行预测，公式如下：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm(Sale_Price ~ Neighborhood + log10(Gr_Liv_Area) + Year_Built + Bldg_Type, data = ames) # 由于Sale_Price取过对数，所以Gr_Liv_Area也取对数\n```\n:::\n\n\n根据预测因子的性质和上述公式，使用`recipe`创建一个特征工程流程。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrecipe(Sale_Price ~ Neighborhood + Gr_Liv_Area + Year_Built + Bldg_Type,\n       data = ames) |> # 创建recipe对象，声明结果变量和预测因子\n  step_log(Gr_Liv_Area) |> # 对Gr_Liv_Area取对数\n  step_dummy(all_nominal_predictors()) -> simple_ames # 对分类变量创建哑变量\n\nsimple_ames\n```\n:::\n\n\n:::callout-tip\n`all_nominal_predictors()`函数用于选择所有的分类变量。\n\n`all_numeric_predictors()`函数用于选择所有的数值变量。\n\n`all_predictors()`函数用于选择所有的预测因子。\n\n`all_outcomes()`函数用于选择所有的结果变量。\n\n`all_numeric()`函数用于选择所有的数值变量。\n:::\n\n### 应用特征工程\n\n将特征工程`simple_ames`应用到workflow`lm_workflow`上。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_workflow |>\n  remove_variables() |> # 删除所有的预测因子\n  remove_recipe() |> # 删除所有的特征工程\n  add_recipe(simple_ames) -> lm_workflow # 添加特征工程\n\nlm_workflow\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n══ Workflow ════════════════════════════════════════════════════════════════════\nPreprocessor: Recipe\nModel: linear_reg()\n\n── Preprocessor ────────────────────────────────────────────────────────────────\n2 Recipe Steps\n\n• step_log()\n• step_dummy()\n\n── Model ───────────────────────────────────────────────────────────────────────\nLinear Regression Model Specification (regression)\n\nComputational engine: lm \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfit(lm_workflow, ames_train) -> lm_fit # 拟合模型\n\npredict(lm_fit, ames_test) |> # 预测测试集\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 1\n  .pred\n  <dbl>\n1  5.07\n2  5.17\n3  5.27\n4  5.08\n5  5.51\n6  5.44\n```\n\n\n:::\n:::\n\n\n使用`extract_*`函数可以提取`fit`对象的不同信息，如模型参数、特征工程等。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_fit |>\n  extract_recipe(estimated = TRUE) # 提取特征工程，estimated = TRUE表示提取特征工程的估计值\n\nlm_fit |>\n  extract_fit_parsnip() |> # 提取模型参数\n  tidy() |>\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n  term                       estimate std.error statistic   p.value\n  <chr>                         <dbl>     <dbl>     <dbl>     <dbl>\n1 (Intercept)                -0.682    0.228        -2.99 2.78e-  3\n2 Gr_Liv_Area                 0.271    0.00606      44.8  1.36e-315\n3 Year_Built                  0.00199  0.000115     17.3  6.19e- 63\n4 Neighborhood_College_Creek  0.0167   0.00807       2.06 3.91e-  2\n5 Neighborhood_Old_Town      -0.0357   0.00844      -4.22 2.50e-  5\n6 Neighborhood_Edwards       -0.0531   0.00755      -7.04 2.57e- 12\n```\n\n\n:::\n:::\n\n\n### 其他特征工程示例\n\n#### 定性变量的处理\n\n:::callout-tip\n`step_unknown()`函数用于将缺失值转化为专用因子水平。\n\n`step_novel()`函数用于将未知的水平转化为新的水平。\n\n`step_other()`函数用于将频率较低的多个水平合并为一个水平，频率阈值可以指定。\n:::\n\n上述函数可以用于处理定性变量的缺失值和未知水平，以及合并频率较低的水平，在此基础上，可以使用`step_dummy()`函数创建哑变量。\n\n#### 交互项的处理\n\n交互项是指两个或多个变量的乘积，可以用于捕捉变量之间的关系。使用`step_interact(~*:*)`函数可以创建交互项。\n\n在ames数据集中，不同建筑类型的房屋可能与不同的居住面积存在交互，如 @fig-ames-interact 所示，可以使用交互项来捕捉这种关系。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(ames_train, aes(x = Gr_Liv_Area, y = 10^Sale_Price)) + \n  geom_point(alpha = .2) + \n  facet_wrap(~ Bldg_Type) + \n  geom_smooth(method = lm, formula = y ~ x, se = FALSE, color = \"lightblue\") + \n  scale_x_log10() + \n  scale_y_log10() + \n  labs(x = \"Gross Living Area\", y = \"Sale Price (USD)\")\n```\n\n::: {.cell-output-display}\n![五种不同类型建筑的总居住面积与销售价格的关系（log10变换后）](tidymodels-base_files/figure-html/fig-ames-interact-1.png){#fig-ames-interact width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrecipe(Sale_Price ~ Neighborhood + Gr_Liv_Area + Year_Built + Bldg_Type,\n         data = ames_train) |> # 创建recipe对象并声明结果变量和预测因子\n  step_log(Gr_Liv_Area, base = 10) |> # 对Gr_Liv_Area取对数\n  step_other(Neighborhood, threshold = 0.01) |> # 合并频率较低的水平\n  step_dummy(all_nominal_predictors()) |> # 对分类变量创建哑变量\n  step_interact( ~ Gr_Liv_Area:starts_with(\"Bldg_Type_\")) -> simple_ames # 创建交互项，其中:表示交互，可以使用+添加多组交互项\n\nsimple_ames\n```\n:::\n\n\n:::callout-warning\n一般来说，交互项需要在创建哑变量后才能创建，否则可能会报错。\n:::\n\n#### 样条函数\n\n样条函数是一种非参数拟合方法，可以用于拟合非线性关系。使用`step_ns()`函数可以创建样条函数。\n\n在ames数据集中，经度和纬度可能与销售价格存在非线性关系，如 @fig-ames-spline 所示，可以使用样条函数来捕捉这种关系。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(splines) # 样条函数\nlibrary(patchwork) # 绘图拼接\n\nplot_smoother <- function(deg_free) { # 创建一个函数，用于绘制不同自由度的样条函数\n  ggplot(ames_train, aes(x = Latitude, y = 10^Sale_Price)) +  # 还原对数变换\n    geom_point(alpha = .2) +  # 添加散点图，alpha表示透明度\n    scale_y_log10() + # 对y轴进行对数变换\n    geom_smooth(\n      method = lm,\n      formula = y ~ ns(x, df = deg_free),\n      color = \"lightblue\",\n      se = FALSE\n    ) + # 添加样条函数，ns表示样条函数，df表示自由度\n    labs(title = paste(deg_free, \"Spline Terms\"),\n         y = \"Sale Price (USD)\")\n}\n\n( plot_smoother(2) + plot_smoother(5) ) / ( plot_smoother(20) + plot_smoother(100) ) # 绘制不同自由度的样条函数\n```\n\n::: {.cell-output-display}\n![销售价格与纬度的关系](tidymodels-base_files/figure-html/fig-ames-spline-1.png){#fig-ames-spline width=672}\n:::\n:::\n\n\n由 @fig-ames-spline 可以看出，自由度为5和20时，样条函数能较好地拟合数据，这里选择自由度为20的样条函数来捕捉纬度与销售价格的关系。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrecipe(Sale_Price ~ Neighborhood + Gr_Liv_Area + Year_Built + Bldg_Type + Latitude,\n         data = ames_train) |>\n  step_log(Gr_Liv_Area, base = 10) |>\n  step_other(Neighborhood, threshold = 0.01) |>\n  step_dummy(all_nominal_predictors()) %>% \n  step_interact( ~ Gr_Liv_Area:starts_with(\"Bldg_Type_\") ) |>\n  step_ns(Latitude, deg_free = 20) # 创建样条函数，自由度为20\n```\n:::\n\n\n#### 特征提取（PCA）\n\n特征提取是指将多个原始特征合并为少数几个新特征，以减少数据维度。使用`step_pca()`函数可以进行主成分分析（PCA）。\n\nPCA是一种线性提取方法，其优点是每个主成分之间互不相关，因此可以减少多重共线性的影响。但是，PCA的缺点是提取的特征不易解释，而且新特征可能与结果无关。\n\n在ames数据集中，有几个预测因子测量了房产的面积，如地下室总面积`Total_Bsmt_SF`、一楼面积`First_Flr_SF`、总居住面积`Gr_Liv_Area`等。PCA 可以将这些潜在的冗余变量表示为一个较小的特征集。除了总居住面积外，这些预测因子的名称中都有后缀`SF`（表示平方英尺）。\n\nPCA假定所有预测因子的单位相同，因此在使用PCA之前，最好使用`step_normalize()`对这些预测因子进行标准化。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep_normalize(matches(\"(SF$)|(Gr_Liv)\")) |>\nstep_pca(matches(\"(SF$)|(Gr_Liv)\"))\n```\n:::\n\n\n:::callout-tip\n特征提取的其他方法还包括独立成分分析（ICA），非负矩阵分解（NMF），多维缩放（MDS），均匀流形近似（UMAP），t-分布邻域嵌入（t-SNE）等。\n:::\n\n#### 抽样技术\n\n类别不平衡问题是指分类问题中不同类别的样本数量差异较大。在这种情况下，模型可能会偏向于预测样本数量较多的类别，而忽略样本数量较少的类别。针对类别不平衡问题，可以采用子采样技术，它通常不会提高整体性能，但可以生成表现更好的预测类概率分布。子采样技术分类如下：\n\n1. 下抽样(Downsampling)：保留少数类样本，对多数类样本进行随机抽样，以平衡频率。\n2. 扩大抽样(Upsampling)：合成新的少数类样本，或直接复制少数类样本，以平衡频率。\n3. Hybrid：结合上述两种方法。\n\n在`themis`包中，`step_downsample()`和`step_upsample()`函数可以实现下抽样和扩大抽样。\n\n:::callout-tip\n`step_filter()`函数可以用于删除不需要的样本，如异常值、缺失值等。\n\n`step_sample()`函数可以用于随机抽样。\n\n`step_slice()`函数可以用于分割数据集。\n\n`step_arrange()`函数可以用于排序数据集。\n:::\n\n#### 一般变换\n\n一般变换是指对数据进行一般性的变换，如对数变换、幂变换、指数变换等。在`recipes`包中，`step_log()`、`step_sqrt()`、`step_YeoJohnson()`、`step_boxcox()`等函数可以实现对数变换、平方根变换、Yeo-Johnson变换、Box-Cox变换等。`step_mutate()`函数可以利用已有变量计算并创建新的变量。\n\n:::callout-warning\n进行一般变换是，需要格外注意避免数据泄露。转换应该在拆分数据集之前进行。\n:::\n\n#### 自然语言处理\n\n自然语言处理（NLP）是指对文本数据进行处理，如分词、词干提取、词形还原、停用词过滤、词频统计、TF-IDF计算等。\n\n`textrecipes`包是`recipes`包的扩展，提供了一系列用于文本数据处理的函数。`step_tokenize()`、`step_stem()`、`step_lemma()`、`step_stopwords()`、`step_tf()`、`step_tfidf()`等函数可以实现分词、词干提取、词形还原、停用词过滤、词频统计、TF-IDF计算等。可以在[Cookbook - Using more complex recipes involving text](https://textrecipes.tidymodels.org/articles/cookbook---using-more-complex-recipes-involving-text.html)中参考相关函数的使用方法。但是，`textrecipes`包目前还不支持中文文本的处理，可能需要使用`jiebaR`包（[jiebaR 中文分词文档](https://qinwenfeng.com/jiebaR/index.html)）等其他包来处理中文文本。\n\n### tidy\n\n首先，为ames数据集创建一个`recipe`对象。然后，使用`tidy()`函数查看`recipe`对象的内容摘要。\n\n`id`参数可以用于指定`recipe`步骤函数的标识符。在多次添加相同的步骤函数时，可以使用`id`参数来区分这些步骤函数。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrecipe(Sale_Price ~ Neighborhood + Gr_Liv_Area + Year_Built + Bldg_Type + \n         Latitude + Longitude, data = ames_train) |>\n  step_log(Gr_Liv_Area, base = 10) |>\n  step_other(Neighborhood, threshold = 0.01, id = \"my_id\") |> # 指定id参数\n  step_dummy(all_nominal_predictors()) |>\n  step_interact( ~ Gr_Liv_Area:starts_with(\"Bldg_Type_\")) |>\n  step_ns(Latitude, Longitude, deg_free = 20) -> ames_recipe\n\names_recipe |>\n  tidy()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 6\n  number operation type     trained skip  id            \n   <int> <chr>     <chr>    <lgl>   <lgl> <chr>         \n1      1 step      log      FALSE   FALSE log_yQoQt     \n2      2 step      other    FALSE   FALSE my_id         \n3      3 step      dummy    FALSE   FALSE dummy_EvyKp   \n4      4 step      interact FALSE   FALSE interact_VANTp\n5      5 step      ns       FALSE   FALSE ns_J20uP      \n```\n\n\n:::\n:::\n\n\n使用`ames_recipe`对象建立workflow：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworkflow() |>\n  add_model(lm_model) |>\n  add_recipe(ames_recipe) -> lm_workflow\n\nlm_workflow |>\n  fit(data = ames_train) -> lm_fit\n```\n:::\n\n\n可以使用`tidy()`函数并指定`id`参数，查看对应`id`步骤的结果，也可以指定`number`参数，查看对应的结果：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_fit |>\n  extract_recipe(estimated = TRUE) |>\n  tidy(id = \"my_id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 21 × 3\n   terms        retained           id   \n   <chr>        <chr>              <chr>\n 1 Neighborhood North_Ames         my_id\n 2 Neighborhood College_Creek      my_id\n 3 Neighborhood Old_Town           my_id\n 4 Neighborhood Edwards            my_id\n 5 Neighborhood Somerset           my_id\n 6 Neighborhood Northridge_Heights my_id\n 7 Neighborhood Gilbert            my_id\n 8 Neighborhood Sawyer             my_id\n 9 Neighborhood Northwest_Ames     my_id\n10 Neighborhood Sawyer_West        my_id\n# ℹ 11 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nlm_fit |>\n  extract_recipe(estimated = TRUE) |>\n  tidy(number = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 25 × 3\n   terms        columns            id         \n   <chr>        <chr>              <chr>      \n 1 Neighborhood College_Creek      dummy_EvyKp\n 2 Neighborhood Old_Town           dummy_EvyKp\n 3 Neighborhood Edwards            dummy_EvyKp\n 4 Neighborhood Somerset           dummy_EvyKp\n 5 Neighborhood Northridge_Heights dummy_EvyKp\n 6 Neighborhood Gilbert            dummy_EvyKp\n 7 Neighborhood Sawyer             dummy_EvyKp\n 8 Neighborhood Northwest_Ames     dummy_EvyKp\n 9 Neighborhood Sawyer_West        dummy_EvyKp\n10 Neighborhood Mitchell           dummy_EvyKp\n# ℹ 15 more rows\n```\n\n\n:::\n:::\n\n\n### \"roles\"变量\n\n有一部分变量，既不是预测变量，也不是因子变量，但在数据集中可能起到建模之外的作用。可以使用`add_role()`, `remove_role()`和`update_role()`函数来指定这些变量的角色。同时，可以为`step_*()`函数指定`roles`参数，不过大部分`step_*()`函数都会自动给定变量的角色。\n\n代码示例：\n\n\n::: {.cell}\n\n```{.r .cell-code}\names_recipe |>\n  update_role(address, new_role = \"street address\") # 对于已建好的recipe对象，使用update_role()函数来更新变量的角色，在构建recipe对象时，应使用add_role()函数。\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n## 模型性能评估\n\n\n::: {.cell}\n\n:::\n\n\n:::callout-important\n重采样方法是最有效的验证方法。\n:::\n\n`yardstick`包是`tidymodels`核心包之一，可以用于模型性能评估。按结果变量的类型，即数值变量、二分类变量和多分类变量，模型性能评估的指标也有所不同。\n\n### 数值变量-回归模型\n\n`ames`数据集的预测模型`lm_fit`包含了回归模型和预测集，同时有交互作用和经纬度样条函数。首先，使用`predict()`函数计算预测值。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm_fit |>\n  predict(new_data = ames_test |>\n            select(-Sale_Price)) -> ames_test_results\n\names_test_results |>\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 1\n  .pred\n  <dbl>\n1  5.07\n2  5.17\n3  5.28\n4  5.05\n5  5.51\n6  5.42\n```\n\n\n:::\n:::\n\n\n将预测值和实际值放在一起，使用`bind_cols()`函数：\n\n\n::: {.cell}\n\n```{.r .cell-code}\names_test_results |>\n  bind_cols(ames_test |>\n              select(Sale_Price)) -> ames_test_results\n\names_test_results |>\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  .pred Sale_Price\n  <dbl>      <dbl>\n1  5.07       5.02\n2  5.17       5.24\n3  5.28       5.28\n4  5.05       5.06\n5  5.51       5.60\n6  5.42       5.33\n```\n\n\n:::\n:::\n\n\n首先，作图查看预测值和实际值的关系：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(ames_test_results, aes(x = Sale_Price, y = .pred)) + \n  geom_abline(lty = 2) + # 添加对角线\n  geom_point(alpha = 0.5) + \n  labs(y = \"Predicted Sale Price (log10)\", x = \"Sale Price (log10)\") +\n  coord_obs_pred() # 使x轴和y轴的刻度一致\n```\n\n::: {.cell-output-display}\n![预测值和实际值的关系(log10)](tidymodels-base_files/figure-html/fig-yardstick_01-1.png){#fig-yardstick_01 width=672}\n:::\n:::\n\n\n由 @fig-yardstick_01 发现，有几个预测值和实际值的偏差较大。使用`rmse()`函数计算均方根误差，`rsq`函数计算R^2，`mae`函数计算平均绝对误差。\n\n\n::: {.cell}\n\n```{.r .cell-code}\names_test_results |>\n  rmse(truth = Sale_Price, estimate = .pred) # 计算单一指标\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 rmse    standard      0.0754\n```\n\n\n:::\n\n```{.r .cell-code}\names_metrics <- metric_set(rmse, rsq, mae) # 创建指标集\n\names_test_results |>\n  ames_metrics(truth = Sale_Price, estimate = .pred) # 同时计算多个指标\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 rmse    standard      0.0754\n2 rsq     standard      0.826 \n3 mae     standard      0.0546\n```\n\n\n:::\n:::\n\n\n### 二分类变量-logistic回归模型\n\n使用`modeldata`包（`tidymodels`核心包之一）中的`two_class_example`数据集，这是一个模拟了logistic回归模型预测结果的数据集。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(two_class_example, package = \"modeldata\")\ntibble(two_class_example) |>\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  truth   Class1   Class2 predicted\n  <fct>    <dbl>    <dbl> <fct>    \n1 Class2 0.00359 0.996    Class2   \n2 Class1 0.679   0.321    Class1   \n3 Class2 0.111   0.889    Class2   \n4 Class1 0.735   0.265    Class1   \n5 Class2 0.0162  0.984    Class2   \n6 Class1 0.999   0.000725 Class1   \n```\n\n\n:::\n:::\n\n\n对于logistic回归模型，模型性能评估指标有很多，列举如下：\n\n- `conf_mat`：混淆矩阵\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntwo_class_example |>\n  conf_mat(truth = truth, estimate = predicted)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          Truth\nPrediction Class1 Class2\n    Class1    227     50\n    Class2     31    192\n```\n\n\n:::\n:::\n\n\n- `accuracy`：准确率\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntwo_class_example |>\n  accuracy(truth = truth, estimate = predicted)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric  .estimator .estimate\n  <chr>    <chr>          <dbl>\n1 accuracy binary         0.838\n```\n\n\n:::\n:::\n\n\n- `mcc`：Matthews相关系数\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntwo_class_example |>\n  mcc(truth = truth, estimate = predicted)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 mcc     binary         0.677\n```\n\n\n:::\n:::\n\n\n- `f_meas`：F1值，精确率和召回率的调和平均数\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntwo_class_example |>\n  f_meas(truth = truth, estimate = predicted)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 f_meas  binary         0.849\n```\n\n\n:::\n:::\n\n\n- `roc_curve`和`roc_auc`：ROC曲线和AUC\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntwo_class_example |>\n  roc_curve(truth = truth, Class1) -> two_class_curve\n\ntwo_class_curve\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 502 × 3\n   .threshold specificity sensitivity\n        <dbl>       <dbl>       <dbl>\n 1 -Inf           0                 1\n 2    1.79e-7     0                 1\n 3    4.50e-6     0.00413           1\n 4    5.81e-6     0.00826           1\n 5    5.92e-6     0.0124            1\n 6    1.22e-5     0.0165            1\n 7    1.40e-5     0.0207            1\n 8    1.43e-5     0.0248            1\n 9    2.38e-5     0.0289            1\n10    3.30e-5     0.0331            1\n# ℹ 492 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\ntwo_class_example |>\n  roc_auc(truth = truth, Class1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 roc_auc binary         0.939\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntwo_class_curve |>\n  autoplot()\n```\n\n::: {.cell-output-display}\n![ROC曲线](tidymodels-base_files/figure-html/fig-yardstick_02-1.png){#fig-yardstick_02 width=672}\n:::\n:::\n\n\n### 多分类变量-多分类模型\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(hpc_cv)\ntibble(hpc_cv) |>\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 7\n  obs   pred     VF      F       M          L Resample\n  <fct> <fct> <dbl>  <dbl>   <dbl>      <dbl> <chr>   \n1 VF    VF    0.914 0.0779 0.00848 0.0000199  Fold01  \n2 VF    VF    0.938 0.0571 0.00482 0.0000101  Fold01  \n3 VF    VF    0.947 0.0495 0.00316 0.00000500 Fold01  \n4 VF    VF    0.929 0.0653 0.00579 0.0000156  Fold01  \n5 VF    VF    0.942 0.0543 0.00381 0.00000729 Fold01  \n6 VF    VF    0.951 0.0462 0.00272 0.00000384 Fold01  \n```\n\n\n:::\n:::\n\n\n对于多分类模型，使用离散类预测的指标函数与二进制指标函数相同，如`accuracy`, `mcc`, `f_meas`等。\n\n其他指标函数包括：\n\n- `sensitivity`：灵敏度，需要用`estimator`参数指定函数\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhpc_cv |>\n  sensitivity(truth = obs, estimate = pred, estimator = \"macro\") # macro表示宏平均\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric     .estimator .estimate\n  <chr>       <chr>          <dbl>\n1 sensitivity macro          0.560\n```\n\n\n:::\n\n```{.r .cell-code}\nhpc_cv |>\n  sensitivity(truth = obs, estimate = pred, estimator = \"micro\") # micro表示微平均\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric     .estimator .estimate\n  <chr>       <chr>          <dbl>\n1 sensitivity micro          0.709\n```\n\n\n:::\n\n```{.r .cell-code}\nhpc_cv |>\n  sensitivity(truth = obs, estimate = pred, estimator = \"macro_weighted\") # macro_weighted表示加权宏平均\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric     .estimator     .estimate\n  <chr>       <chr>              <dbl>\n1 sensitivity macro_weighted     0.709\n```\n\n\n:::\n:::\n\n\n- `roc_auc`：多分类模型的AUC，必须向函数提供所有的类别概率列\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhpc_cv |>\n  roc_auc(truth = obs, VF, F, M, L) # 这里也可以指定estimator参数\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 roc_auc hand_till      0.829\n```\n\n\n:::\n:::\n\n\n`hpc_cv`数据集中，有`Resample`列，是交叉验证的分组。可以利用`group_by()`函数为每个分组计算指标或作图，如 @fig-yardstick_03 所示。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhpc_cv |>\n  group_by(Resample) |>\n  roc_curve(obs, VF, F, M, L) |>\n  autoplot()\n```\n\n::: {.cell-output-display}\n![分组ROC曲线](tidymodels-base_files/figure-html/fig-yardstick_03-1.png){#fig-yardstick_03 width=672}\n:::\n:::\n",
    "supporting": [
      "tidymodels-base_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}